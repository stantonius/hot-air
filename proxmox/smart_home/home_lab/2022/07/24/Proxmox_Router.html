<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Proxmox network routing with NAT and Tailscale | A Technical Hobbyists Blog</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Proxmox network routing with NAT and Tailscale" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="One approach to remotely connect to VMs on a private local subnet" />
<meta property="og:description" content="One approach to remotely connect to VMs on a private local subnet" />
<link rel="canonical" href="https://stantonius.github.io/home/proxmox/smart_home/home_lab/2022/07/24/Proxmox_Router.html" />
<meta property="og:url" content="https://stantonius.github.io/home/proxmox/smart_home/home_lab/2022/07/24/Proxmox_Router.html" />
<meta property="og:site_name" content="A Technical Hobbyists Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-07-24T00:00:00-05:00" />
<script type="application/ld+json">
{"datePublished":"2022-07-24T00:00:00-05:00","url":"https://stantonius.github.io/home/proxmox/smart_home/home_lab/2022/07/24/Proxmox_Router.html","@type":"BlogPosting","headline":"Proxmox network routing with NAT and Tailscale","dateModified":"2022-07-24T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://stantonius.github.io/home/proxmox/smart_home/home_lab/2022/07/24/Proxmox_Router.html"},"description":"One approach to remotely connect to VMs on a private local subnet","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/home/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://stantonius.github.io/home/feed.xml" title="A Technical Hobbyists Blog" /><!-- the google_analytics_id gets auto inserted from the config file -->



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZYM0GN6Q4W"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZYM0GN6Q4W');
</script>


<link rel="shortcut icon" type="image/x-icon" href="/home/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/home/">A Technical Hobbyists Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/home/about/">About Me</a><a class="page-link" href="/home/search/">Search</a><a class="page-link" href="/home/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Proxmox network routing with NAT and Tailscale</h1><p class="page-description">One approach to remotely connect to VMs on a private local subnet</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-07-24T00:00:00-05:00" itemprop="datePublished">
        Jul 24, 2022
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      13 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/home/categories/#proxmox">proxmox</a>
        &nbsp;
      
        <a class="category-tags-link" href="/home/categories/#smart_home">smart_home</a>
        &nbsp;
      
        <a class="category-tags-link" href="/home/categories/#home_lab">home_lab</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#update-08-08-2022">Update 08-08-2022</a>
<ul>
<li class="toc-entry toc-h3"><a href="#temporary-fix">Temporary Fix</a></li>
<li class="toc-entry toc-h3"><a href="#future-solutions">Future Solutions</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#objective">Objective</a></li>
<li class="toc-entry toc-h2"><a href="#steps">Steps</a>
<ul>
<li class="toc-entry toc-h3"><a href="#1-create-a-second-virtual-network-bridge">1. Create a second Virtual Network Bridge</a></li>
<li class="toc-entry toc-h3"><a href="#2-connect-additional-bridge-to-the-internet">2. Connect additional bridge to the internet</a></li>
<li class="toc-entry toc-h3"><a href="#3-create-vm-and-connect-to-new-bridge">3. Create VM and connect to new bridge</a>
<ul>
<li class="toc-entry toc-h4"><a href="#set-static-ip-address-for-vm">Set static IP address for VM</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#4-enable-port-forwarding">4. Enable port forwarding</a>
<ul>
<li class="toc-entry toc-h4"><a href="#port-forwarding-with-tailscale-vpn">Port forwarding with Tailscale VPN</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#5-e2e-test-with-docker-image">5. E2E test with Docker image</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#additional-notes">Additional Notes</a>
<ul>
<li class="toc-entry toc-h3"><a href="#resources">Resources</a></li>
</ul>
</li>
</ul><h2 id="update-08-08-2022">
<a class="anchor" href="#update-08-08-2022" aria-hidden="true"><span class="octicon octicon-link"></span></a>Update 08-08-2022</h2>

<p>Unfortunately this configuration doesn’t actually work as intended. The issue is that, while all of the devices on the new subnet can access the internet, no device on my other local networks can communicate with devices on this subnet. Furthermore, I fooled myself into <em>thinking it was working</em> when I wrote the post below - when my Mac is connected to the Tailscale VPN, it can <em>see</em> the subnet gateway <code class="language-plaintext highlighter-rouge">192.168.99.1</code> because we configured Tailscale VPN node running on the Proxmox server to <a href="https://tailscale.com/kb/1019/subnets/?tab=linux">advertise the subnet &amp; enable port forwarding</a>.  Therefore any device that is connected to the Tailscale VPN “sees” the subnet gateway being advertised. As anyone who works with Tailscale knows, it runs so smoothly in the background it is easy to forget you are connected - hence my false belief this setup was working.</p>

<p>Upon reflection, this lack of communication between home subnets makes total sense. How is a device (like a Raspberry Pi) that is connected to my home Wifi network supposed to find the gateway of the other network? Within the Tailscale VPN, we specifically configured it so that subnets are advertised on the network. However any device on the regular home network is not aware the subnet exists - they are only connected to the home router, which itself is unaware of the subnet too.</p>

<h3 id="temporary-fix">
<a class="anchor" href="#temporary-fix" aria-hidden="true"><span class="octicon octicon-link"></span></a>Temporary Fix</h3>
<p>Because I am leaving for vacation for a few weeks (and I want a working setup before I go), I have decided to remove the <code class="language-plaintext highlighter-rouge">vmbr1</code> subnet bridge from my Proxmox hosts for the time being. This means that all Proxmox hosts will be visible on my main home network (via the default <code class="language-plaintext highlighter-rouge">vmbr0</code>) and will be assigned LAN IP’s via my router’s DHCP.</p>

<h3 id="future-solutions">
<a class="anchor" href="#future-solutions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Future Solutions</h3>
<p>Upon my return, there are a couple of options I will explore.</p>

<ol>
  <li>All smart home devices will join the Tailscale VPN. This would solve the issue for any device that <em>can</em> run a Tailscale node, but it is not scaleable and also won’t work for any devices that aren’t configurable like a Raspberry Pi</li>
  <li>Set up a configurable router (like OpenWRT) to direct traffic to out subnet. Tutorials found <a href="https://www.youtube.com/watch?v=UvniZs8q3eU">here</a> and <a href="https://youtu.be/R67wEo2V710">here</a>
</li>
  <li>Use a managed switch to configure a VLAN, even when I only have a single NIC (example of how to do this is <a href="https://youtu.be/ljq6wlzn4qo">here</a>)</li>
  <li>There may be some magic I can do with the <code class="language-plaintext highlighter-rouge">iptables</code> on the Raspberry Pis to “make them aware” of the subnet. I am not sure about whether this option even makes sense - I still have a lot to learn about iptables.
    <ol>
      <li>Additionally, Raspian OS doesn’t have <code class="language-plaintext highlighter-rouge">iptables</code> by default, so I would need to install and risk locking myself out of the Pis</li>
    </ol>
  </li>
  <li>Make the temporary solution permanent. I wanted to create a subnet both for my own learning, as well as future-proofing my setup in case I wanted to have some public-facing Proxmox hosts. However neither of these are critical requirements yet.</li>
  <li>Look at the <em>experimental</em> <a href="https://pve.proxmox.com/pve-docs/chapter-pvesdn.html">Software Defined Network</a>  option coming to Proxmox. This may be the most promising option - but I want to wait for it to become more stable before I go this route.</li>
</ol>

<h2 id="objective">
<a class="anchor" href="#objective" aria-hidden="true"><span class="octicon octicon-link"></span></a>Objective</h2>

<p>I have set up a Tailscale VPN on my main Proxmox server. Now I want to route traffic to &amp; from all of the VMs and LXC apps in my server without having to install Tailscale on every machine (I know, this is <a href="https://tailscale.com/kb/1019/subnets/">counter to what they recommend</a>, but I am trying to better understand networking so this is a good project).</p>

<p>I have learnt that what I am trying to achieve is colloquially called a <strong>router on a stick</strong></p>

<h2 id="steps">
<a class="anchor" href="#steps" aria-hidden="true"><span class="octicon octicon-link"></span></a>Steps</h2>
<h3 id="1-create-a-second-virtual-network-bridge">
<a class="anchor" href="#1-create-a-second-virtual-network-bridge" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. Create a second Virtual Network Bridge</h3>
<p>We need to create a new virtual network bridge that all the subnet host machines will connect to. <a href="https://youtu.be/Q5l7VH6b5r4">This Youtube video</a> was excellent in solidifying my plan and understanding. I wanted to do this to both learn about networking but also to avoid having many new devices connected to my home network - while I’m not at risk of using up my allotted 255 local network IP limit, I wanted an easier way to organize all the VMs and containers that will be using this network.</p>

<p>In Proxmox, select your main server node, then <em>Networking &gt; Create &gt; Linux Bridge</em>.</p>

<p><img src="https://storage.googleapis.com/craigstanton-public-assets/images/proxmox_server/proxmoxVE_2ndbridge.png" alt=""></p>

<p>It was important for me to understand that I could <strong>use any subnet range here</strong> when creating this bridge - therefore we are effectively creating a <em>virtual</em> Local Area Network (<strong>vLAN</strong>).</p>

<blockquote>
  <p>This might not be technically true that this setup is a vLAN. But as far as I can tell, because this is a custom subnet that I configured, any VM or container that uses this <code class="language-plaintext highlighter-rouge">vmbr1</code> bridge will join this subnet. As such, this is a unique network that was set up with software - hence vLAN.</p>
</blockquote>

<blockquote>
  <p><strong>Update 08-08-2022</strong>: A great post <a href="https://networkengineering.stackexchange.com/a/28468">here</a> confirms that VLANs and subnets are <strong>different</strong>. While they often go hand-in-hand, VLANs create isolated networks at Layer 2 (ie. groups of <strong>ethernet</strong> devices isolated while on the same physical infrastructure); subnets are just blocks of IP addresses that know how to reach eachother <strong>without going via the gateway/router</strong>.</p>
</blockquote>

<h3 id="2-connect-additional-bridge-to-the-internet">
<a class="anchor" href="#2-connect-additional-bridge-to-the-internet" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. Connect additional bridge to the internet</h3>

<p>Now that we have created a second Linux bridge <code class="language-plaintext highlighter-rouge">vmbr1</code>, we need to configure the main Proxmox server node to route traffic from this second bridge to the main gateway. This is done via a Network Address Translation (<strong>NAT</strong>; as a reminder, NAT is the process of allowing private IPs to use the same single Public IP; more on networking can be found <a href="https://stantonius.github.io/home/networking/computer_science/2022/07/20/Networking_Keys_Summary.html">here</a>).</p>

<p>Configuring NAT in our case involves updating the iptables to bridge traffic from our new network to the internet via <code class="language-plaintext highlighter-rouge">vmbr0</code> (which is connected to the physical port <code class="language-plaintext highlighter-rouge">enp6s0</code>). To set up NAT, edit <code class="language-plaintext highlighter-rouge">/etc/network/interfaces</code> to look like the following:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
auto lo
iface lo inet loopback

iface enp6s0 inet manual

auto vmbr0
iface vmbr0 inet static
        address 192.168.0.207/24
        gateway 192.168.0.1
        bridge-ports enp6s0
        bridge-stp off
        bridge-fd 0

auto vmbr1
iface vmbr1 inet static
        address 192.168.99.1/24
        bridge-ports none
        bridge-stp off
        bridge-fd 0
        post-up <span class="nb">echo </span>1 <span class="o">&gt;</span> /proc/sys/net/ipv4/ip_forward
        post-up iptables <span class="nt">-t</span> nat <span class="nt">-A</span> POSTROUTING <span class="nt">-s</span> <span class="s1">'192.168.99.0/24'</span> <span class="nt">-o</span> vmbr0 <span class="nt">-j</span> MASQUERADE
        post-down iptables <span class="nt">-t</span> nat <span class="nt">-D</span> POSTROUTING <span class="nt">-s</span> <span class="s1">'192.168.99.0/24'</span> <span class="nt">-o</span> vmbr0 <span class="nt">-j</span> MASQUERADE
</code></pre></div></div>

<p>The important section to focus on here is everything under <code class="language-plaintext highlighter-rouge">auto vmbr1</code>.  Everything up to <code class="language-plaintext highlighter-rouge">bridge-fd 0</code> was added by Proxmox when I created the new bridge in the GUI (and after a reboot). However the last 3 lines are the NAT config that are added manually - these lines are what allow traffic <em>from</em> this subnet to reach the internet.</p>

<p>You can check the config of this new network by running <code class="language-plaintext highlighter-rouge">ip address show dev vmbr1</code>. The output should show the gateway ip address you configured.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5: vmbr1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000
    link/ether xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff
    inet **192.168.99.1/24** scope global vmbr1
       valid_lft forever preferred_lft forever
</code></pre></div></div>

<h3 id="3-create-vm-and-connect-to-new-bridge">
<a class="anchor" href="#3-create-vm-and-connect-to-new-bridge" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Create VM and connect to new bridge</h3>
<p>The next step is to create a VM that is connected to our new <code class="language-plaintext highlighter-rouge">vmbr1</code> bridge. I chose the <a href="https://releases.ubuntu.com/22.04/ubuntu-22.04-live-server-amd64.iso">Ubuntu 20.04 server iso</a> as the image for the VM. After running through the GUI setup and setting the disk size to 50GB with 4096MB of RAM, we end up at the <em>Networking</em> tab. Here is where we select our new bridge <code class="language-plaintext highlighter-rouge">vmbr1</code> we created above.</p>

<p><img src="https://storage.googleapis.com/craigstanton-public-assets/images/proxmox_server/proxmoxVE_VMbr1.png" alt=""></p>

<h4 id="set-static-ip-address-for-vm">
<a class="anchor" href="#set-static-ip-address-for-vm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Set static IP address for VM</h4>
<p>Next we need to start and configure the VM. During the setup, you are asked to configure the network since it cannot be inferred. However there are additonal parameters needed in order to set up the network correctly that cannot be done during installation. Therefore it was easiest for me to <em>Continue without network</em>. Don’t forget to enable OpenSSH server if asked.</p>

<p>Once the installation is complete, log in to the VM and edit the file <code class="language-plaintext highlighter-rouge">00-installer-config.yaml</code> located in <code class="language-plaintext highlighter-rouge">/etc/netplan</code>.</p>

<blockquote>
  <p>The above instructions apply to <strong>Ubuntu distros v18.04+</strong>. For other Linux distros, the network config is probably found in <code class="language-plaintext highlighter-rouge">/etc/network/interfaces</code></p>
</blockquote>

<p>Because we skipped the networking config during installation, <code class="language-plaintext highlighter-rouge">00-installer-config.yaml</code> probably looks something like this:</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">network</span><span class="pi">:</span>
  <span class="na">ethernets</span><span class="pi">:</span>
    <span class="na">ens18</span><span class="pi">:</span>
      <span class="na">dhcp4</span><span class="pi">:</span> <span class="no">true</span>
  <span class="na">version</span><span class="pi">:</span> <span class="m">2</span>
</code></pre></div></div>

<p>Choose your favourite text editor and update the file to add your VMs static IP address (including the network mask slash notation):</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">network</span><span class="pi">:</span>
  <span class="na">ethernets</span><span class="pi">:</span>
    <span class="na">ens18</span><span class="pi">:</span>
<span class="err">	</span>  <span class="na">addresses</span><span class="pi">:</span> 
<span class="err">	</span>  <span class="pi">-</span> <span class="s">192.168.99.99/24</span>
<span class="err">	</span>  <span class="na">gateway4</span><span class="pi">:</span> <span class="s">192.168.99.1</span>
<span class="err">	</span>  <span class="na">nameservers</span><span class="pi">:</span>
<span class="err">		</span><span class="na">addresses</span><span class="pi">:</span>
<span class="err">		</span><span class="pi">-</span> <span class="s">1.1.1.1</span>
<span class="err">		</span><span class="s">- 8.8.8.8</span>
<span class="err">		</span><span class="na">search</span><span class="pi">:</span> <span class="pi">[]</span>
  <span class="na">version</span><span class="pi">:</span> <span class="m">2</span>
</code></pre></div></div>

<p>Notice that the gateway address is the same as the address we entered when creating our <code class="language-plaintext highlighter-rouge">vmbr1</code> bridge. Combined with updating our main server node’s ip tables, this configuration allows our machine to connect <em>to</em> the internet.</p>

<p>How do we allow for incoming traffic to these machines on a separate vLAN?</p>

<h3 id="4-enable-port-forwarding">
<a class="anchor" href="#4-enable-port-forwarding" aria-hidden="true"><span class="octicon octicon-link"></span></a>4. Enable port forwarding</h3>
<p>In order to SSH <em>into</em> our new VM, we have to configure the Proxmox main node to forward any requests to a particular port over <em>on the main server node</em> to the <code class="language-plaintext highlighter-rouge">ip.add.re.ss:port</code> of the VM. We do this with the following command:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables -t nat -A PREROUTING -i vmbr0 -p tcp -m tcp --dport 10122 -j DNAT --to-destination 192.168.99.99:22
</code></pre></div></div>

<p>If you visit <a href="https://gist.github.com/basoro/b522864678a70b723de970c4272547c8">this gist</a>, there are awesome suggestions on how to map ports in a systemic way. Here for example, the main server port <code class="language-plaintext highlighter-rouge">10122</code> will map to machine ID <code class="language-plaintext highlighter-rouge">101</code> on port <code class="language-plaintext highlighter-rouge">22</code>.</p>

<p>Now SSH’ing into the VM requires one additional port argument as shown below:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-p</span> 10122 craig@192.168.0.55
</code></pre></div></div>

<p>Notice something funky here:</p>
<ol>
  <li>The user (<code class="language-plaintext highlighter-rouge">craig</code>) is the user <em>of the VM</em>, not the user of the main server node</li>
  <li>The IP address is that of the <em>main server node</em>
</li>
</ol>

<p>We have no achieved bi-directional access to our VMs on a custom local subnet - our VMs can access the internet via our NAT setup, and we can access the VMs via port-forwarding via a router on the main server node.</p>

<h4 id="port-forwarding-with-tailscale-vpn">
<a class="anchor" href="#port-forwarding-with-tailscale-vpn" aria-hidden="true"><span class="octicon octicon-link"></span></a>Port forwarding with Tailscale VPN</h4>
<p>Without any changes, the setup described above would only allow access to the new VM while on the <em>local network</em>. However we want to be able to also connect remotely - and the solution I have chosen is to use Tailscale VPN instead of enabling port forwarding or reverse proxy on our <em>home</em> consumer router.</p>

<p>We have two options on how to set up our Tailscale VPN. The first, as alluded to in the intro, is to install Tailscale on all of our VMs on our subnet. For various reasons, both practical and stubborn, I decided against this.</p>

<p>The second option was to add Tailscale to our subnet router that we set up above, which is the option I chose. Lucky for us, Tailscale has good documentation that describes exactly how to create a <a href="https://tailscale.com/kb/1019/subnets/?tab=linux">subnet router</a>. There is no point repeating here what is perfectly laid out in the docs, but there are a couple of setup items to be aware of:</p>

<ol>
  <li>If you are running the Tailscale router on the main Proxmox server node as I am, you need <strong>both of the arguments below</strong> when starting Tailscale in that server:
    <div class="language-bash highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>tailscale up <span class="nt">--advertise-routes</span><span class="o">=</span>192.168.99.0/24 <span class="nt">--accept-routes</span>
</code></pre></div>    </div>
    <p>where <code class="language-plaintext highlighter-rouge">--advertise-routes=[your_local_subnet]</code> and the <code class="language-plaintext highlighter-rouge">--accept-routes</code> argument is required for any Linux machines to listen for the new subnet range (yes, this is sending the message back to itself as our router is also a Linux box).</p>
  </li>
  <li>
    <p>This may have been obvious to those more familiar with VPN, but to SSH into a machine over a Tailscale VPN, you actually <strong>call the local IP address of the VM</strong> <em>as if you were on your home network</em>. For example, instead of calling <code class="language-plaintext highlighter-rouge">ssh -p 10122 craig@100.80.101.92</code>, where the IP address is the Tailscale IP address for the main server node, you actually call <code class="language-plaintext highlighter-rouge">ssh craig@192.168.99.99</code>, where the local subnet IP address of your VM. This took me <em>way longer than it should have to figure out</em>, and this fact is not mentioned in the docs (maybe because it should be obvious?).</p>

    <p>Furthermore, what also surprised me was that I <strong>didn’t have to specify the port</strong> when SSH’ing into the VM with the IP address <code class="language-plaintext highlighter-rouge">192.168.99.99</code>. As it turns out, the port forwarding iptables rules we configured on the router in the previous section <em>already handles the port mapping depending on the incoming traffic type</em>.</p>

    <p>This Tailscale setup also suggests to me that your local subnet range should be slightly unique (ie. still uses a typical 192/10/172 address). By unique I mean the third octet, for example, is a non-traditional number (ie. 99 instead of 0) - because if you are on another network calling the VM address but another device has that same IP address, there will be address clashing.</p>
  </li>
</ol>

<p>To summarize where we are now: we have a Proxmox VM that is connected to a private local subnet, but can reach the internet and is accessible via SSH anywhere in the world (so long as we are logged in to Tailscale).</p>

<h3 id="5-e2e-test-with-docker-image">
<a class="anchor" href="#5-e2e-test-with-docker-image" aria-hidden="true"><span class="octicon octicon-link"></span></a>5. E2E test with Docker image</h3>
<p>The final test for a complete system is to spin up a Docker image running a server to test that it is accessible via an external (albeit authenticated) device. To do this I will run a default nginx server and access it via a browser. Therefore the first thing I need to do is to at to our port forwarding iptables on our Proxmox main server node. To do this we run the following in the main server shell:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables <span class="nt">-t</span> nat <span class="nt">-A</span> PREROUTING <span class="nt">-i</span> vmbr0 <span class="nt">-p</span> tcp <span class="nt">-m</span> tcp <span class="nt">--dport</span> 10180 <span class="nt">-j</span> DNAT <span class="nt">--to-destination</span> 192.168.99.99:80
</code></pre></div></div>

<p>Once we know we can reach our test site via HTTP, we can run the following in our new VM shell:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> <span class="nb">test</span> <span class="nt">-p</span> 80:80 <span class="nt">-d</span> nginx
</code></pre></div></div>

<p>Now, while connected via Tailscale (perhaps the best test is via your mobile with the Wifi turned off, just to be extra thorough), enter in your VMs private IP address in your browser. Magically, the default nginx server page welcomes you.</p>

<h2 id="additional-notes">
<a class="anchor" href="#additional-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Additional Notes</h2>
<p>Some may argue that we shouldn’t be using our main Proxmox server node as the network traffic router. I’m guessing it is to fully segregate responsibilities - leave the main server fully clean and spin up a container router that is purely for network traffic routing. If I notice any problems with the setup described above, I might try this bespoke router container approach - but for now, I just want a working stable setup, which is what I have managed to build.</p>

<h3 id="resources">
<a class="anchor" href="#resources" aria-hidden="true"><span class="octicon octicon-link"></span></a>Resources</h3>
<ul>
  <li>https://youtu.be/Q5l7VH6b5r4*</li>
  <li><a href="https://gist.github.com/basoro/b522864678a70b723de970c4272547c8">Running Proxmox behind a single IP address (github.com)</a></li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>[Create Private Network Bridge on Proxmox VE with NAT</td>
          <td>ComputingForGeeks](https://computingforgeeks.com/create-private-network-bridge-proxmox-with-nat/)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li><a href="https://tailscale.com/kb/1019/subnets/">Subnet routers and traffic relay nodes · Tailscale</a></li>
  <li><a href="https://youtu.be/kthHizueMiY">The Digital Life networking video that mentions calling the local IP address over Tailscale</a></li>
</ul>


  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="stantonius/home"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/home/proxmox/smart_home/home_lab/2022/07/24/Proxmox_Router.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/home/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/home/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/home/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Posts related to AI, IoT, Home Labs, Flutter, GCP, Privacy-Enhancing Tech...the list grows every week.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/stantonius" target="_blank" title="stantonius"><svg class="svg-icon grey"><use xlink:href="/home/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/thecraigman22" target="_blank" title="thecraigman22"><svg class="svg-icon grey"><use xlink:href="/home/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
